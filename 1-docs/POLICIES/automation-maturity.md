# 自动化成熟度路线（Automation Maturity）

## 阶段一：把“训练方案”变成“可执行判定树”

**目标：不写自动化，只写“if / else 思维”**

你可以做的事情：

- 把每个场景拆成：
    
    - 输入指标
        
    - 判定条件
        
    - 禁止动作
        
    - 必须升级的条件
        

例如：

> 如果 load 高 && CPU idle 高  
> → 判定 IO 或 D 状态  
> → 禁止 restart  
> → 要求查看 vmstat / iotop

这一步，**不需要任何工具**，但极其关键。

---

## 阶段二：做“只读自动化”（Read-only Automation）

**目标：系统自动“看”和“说”，但不“动”**

这是自动化运维里最安全、也最容易被低估的一层。

你可以训练：

- 自动采集：
    
    - uptime / free / vmstat / ss
        
- 自动归类：
    
    - 资源型 / 状态型 / 队列型
        
- 自动输出：
    
    - 一段“系统语言结论草稿”
        

例如：

> “当前系统 load=12，CPU idle=78%，wa=18%，  
> 推测阻塞发生在 IO 层，存在 D 状态风险，  
> 不建议重启服务。”

这一步，是**人机协作最理想的切入点**。

---

## 阶段三：有限自动行动（Guarded Automation）

**目标：只自动做“可逆、低风险、止损型动作”**

例如：

- 自动标记异常节点
    
- 自动摘流量
    
- 自动限流
    
- 自动通知并附带上下文
    

但必须满足三个条件：

1. 行为可回滚
    
2. 不改变系统状态本质
    
3. 人可以随时介入
    

这一步，**不是“修问题”，而是“保护系统”**。
